name: CD Pipeline

on:
  push:
    branches:
      - develop
      - main
    tags:
      - 'v*'

env:
  TERRAFORM_DIR: terraform/minikube-setup
  TERRAFORM_KUMA_DIR: terraform/kuma-monitoring
  SCRIPTS_DIR: scripts

jobs:
  deploy:
    runs-on: self-hosted

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set environment name
        id: envname
        run: |
          if [[ "${GITHUB_REF}" == "refs/heads/develop" ]]; then
            echo "env=development" >> $GITHUB_OUTPUT
          elif [[ "${GITHUB_REF}" == "refs/heads/main" ]]; then
            echo "env=staging" >> $GITHUB_OUTPUT
          elif [[ "${GITHUB_REF}" == refs/tags/* ]]; then
            echo "env=production" >> $GITHUB_OUTPUT
          else
            echo "env=unknown" >> $GITHUB_OUTPUT
          fi

      - name: Debug PATH and Minikube
        run: |
          echo $PATH
          ls -l /usr/local/bin/minikube
          /usr/local/bin/minikube version || echo "minikube failed"

      - name: Start Minikube (if not already running)
        run: |
          export PATH=$PATH:/usr/local/bin
          minikube status || minikube start --driver=docker

      - name: Enable Minikube Ingress
        run: |
          export PATH=$PATH:/usr/local/bin
          minikube addons enable ingress

      - name: Ensure Namespace Exists
        run: |
          NS=${{ steps.envname.outputs.env }}
          if [[ "$NS" != "unknown" ]]; then
            kubectl get namespace $NS 2>/dev/null || \
            (kubectl create namespace $NS && echo "Namespace $NS created") || \
            (echo "Namespace $NS already exists, continuing...")
          fi

      - name: Install or upgrade MongoDB with Helm
        run: |
          NS=${{ steps.envname.outputs.env }}
          if [[ "$NS" != "unknown" ]]; then
            helm repo add bitnami https://charts.bitnami.com/bitnami || true
            helm repo update
            helm upgrade --install mongo bitnami/mongodb \
            --set auth.enabled=false \
            --set architecture=standalone \
            --set resources.requests.cpu=500m \
            --set resources.requests.memory=1Gi \
            --set resources.limits.cpu=1 \
            --set resources.limits.memory=2Gi \
            --set livenessProbe.initialDelaySeconds=60 \
            --set livenessProbe.timeoutSeconds=20 \
            --set readinessProbe.initialDelaySeconds=20 \
            --set readinessProbe.timeoutSeconds=10 \
            -n $NS
          else
            echo "Unknown environment, skipping MongoDB install"
          fi

      - name: Setup Main Terraform (tolerate errors)
        run: |
          set +e
          cd $TERRAFORM_DIR
          terraform init
          terraform apply -auto-approve 2>&1 | tee tfout.log
          TF_EXIT=${PIPESTATUS[0]}
          if grep -q 'already exists' tfout.log; then
            echo "Some resources already exist, skipping error."
            exit 0
          fi
          exit $TF_EXIT

      - name: Clean kuma-monitoring namespace
        run: |
          chmod +x $SCRIPTS_DIR/clean-kuma-monitoring.sh
          $SCRIPTS_DIR/clean-kuma-monitoring.sh

      - name: Setup Kuma Uptime with Terraform
        run: |
          cd $TERRAFORM_KUMA_DIR
          terraform init
          terraform apply -auto-approve

      - name: Map environment to script short name
        id: envshort
        run: |
          case "${{ steps.envname.outputs.env }}" in
            development)
              echo "short=dev" >> $GITHUB_OUTPUT
              ;;
            staging)
              echo "short=stg" >> $GITHUB_OUTPUT
              ;;
            production)
              echo "short=prod" >> $GITHUB_OUTPUT
              ;;
            *)
              echo "short=unknown" >> $GITHUB_OUTPUT
              ;;
          esac

      - name: Cleanup existing Vault setup
        run: |
          chmod +x $SCRIPTS_DIR/cleanup-vault.sh
          $SCRIPTS_DIR/cleanup-vault.sh

      - name: Setup Vault dynamically based on environment 
        run: |
          chmod +x $SCRIPTS_DIR/setup-vault.sh
          $SCRIPTS_DIR/setup-vault.sh ${{ steps.envname.outputs.env }}
           kubectl wait --for=condition=ready pod -l app.kubernetes.io/name=vault -n vault --timeout=180s

      - name: Deploy with Helm
        run: |
          chmod +x $SCRIPTS_DIR/deploy-${{ steps.envshort.outputs.short }}.sh
          $SCRIPTS_DIR/deploy-${{ steps.envshort.outputs.short }}.sh --history-max 3

      - name: Start Environment Port-Forwarding Scripts
        run: |
          chmod +x $SCRIPTS_DIR/port-forward-${{ steps.envshort.outputs.short }}.sh
          nohup $SCRIPTS_DIR/port-forward-${{ steps.envshort.outputs.short }}.sh &
